



## 4. 翻转树
[Leetcode / 力扣](https://leetcode-cn.com/problems/invert-binary-tree/submissions/)
1. 用递归
2. 用stack

```py
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root: return []
        if not root.left and not root.right: return root
        root.left,root.right = root.right,root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
```

## 5. 归并两棵\*
617\. Merge Two Binary Trees (Easy)
[Leetcode](https://leetcode.com/problems/merge-two-binary-trees/description/) / [力扣](https://leetcode-cn.com/problems/merge-two-binary-trees/description/)
> Note: 要注意非递归的方法, 要用两元数组

```py
if not t1 and not t2: return None
        if not t1 and t2 != None: return t2
        if t1 != None and not t2: return t1
        t1.val = t1.val + t2.val
        t1.left = self.mergeTrees(t1.left,t2.left)
        t1.right = self.mergeTrees(t1.right,t2.right)
        return t1
```

> 再练一下非递归方法


## 6. 判断路径和是否等于一个数\*
[力扣](https://leetcode-cn.com/problems/path-sum/description/)
> 需要练一下递归和非递归


## 7. 统计路径和等于一个数的路径数量\*
437\. Path Sum III (Easy)
[Leetcode](https://leetcode.com/problems/path-sum-iii/description/) / [力扣](https://leetcode-cn.com/problems/path-sum-iii/description/)
> 没说停下

## 8. 子树
572\. Subtree of Another Tree (Easy)
[Leetcode](https://leetcode.com/problems/subtree-of-another-tree/description/) / [力扣](https://leetcode-cn.com/problems/subtree-of-another-tree/description/)
> 

## 9. 树的对称
101\. Symmetric Tree (Easy)
[Leetcode](https://leetcode.com/problems/symmetric-tree/description/) / [力扣](https://leetcode-cn.com/problems/symmetric-tree/description/)
> 双指针, 需要多练这题


## 10. 最小路径\*
111\. Minimum Depth of Binary Tree (Easy)
[Leetcode](https://leetcode.com/problems/minimum-depth-of-binary-tree/description/) / [力扣](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/)

## 11. 统计左叶子节点的和\*
404\. Sum of Left Leaves (Easy)
[Leetcode](https://leetcode.com/problems/sum-of-left-leaves/description/) / [力扣](https://leetcode-cn.com/problems/sum-of-left-leaves/description/)
> class.def里定义局部函数调用比self.def快

## 12. 相同节点值的最大路径长度\**
687\. Longest Univalue Path (Easy)
[Leetcode](https://leetcode.com/problems/longest-univalue-path/) / [力扣](https://leetcode-cn.com/problems/longest-univalue-path/)
> 考虑情况有点多, 需要多练这题


## 13. 间隔遍历\*
337\. House Robber III (Medium)
[Leetcode](https://leetcode.com/problems/house-robber-iii/description/) / [力扣](https://leetcode-cn.com/problems/house-robber-iii/description/)
> 需要再练, 需要用到二维数组


## 14. 找出二叉树中第二小的节点/*
671\. Second Minimum Node In a Binary Tree (Easy)
[Leetcode](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/description/) / [力扣](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/description/)
> 需要多练这题, 需要尝试一下递归

```py
class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        # 输出最大和第二大的值
        h = [-float('inf'), -float('inf')]
        def f(r):
            if r:
                -r.val not in h and heapq.heappushpop(h, -r.val)
                f(r.left)
                f(r.right)
        f(root)
        return h[0] == -float('inf') and -1 or -h[0]
```
**Note: Hard to read this code, please check it!**
> Remark: `return a and b` is equal to `return b if a else a`; `a or b` is equal to `a if a else b`

# 层次遍历
## 1. 一棵树每层节点的平均数
637\. Average of Levels in Binary Tree (Easy)
[Leetcode](https://leetcode.com/problems/average-of-levels-in-binary-tree/description/) / [力扣](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/description/)
> 啊, 需要再练, 层次遍历, 需要借助两个list
> 需要在考虑一下深度优先

## 2. 得到左下角的节点\*
513\. Find Bottom Left Tree Value (Easy)
[Leetcode](https://leetcode.com/problems/find-bottom-left-tree-value/description/) / [力扣](https://leetcode-cn.com/problems/find-bottom-left-tree-value/description/)
> 下次用DFS

# 前中后序遍历
## 1. 非递归实现二叉树的前序遍历
144\. Binary Tree Preorder Traversal (Medium)
[Leetcode](https://leetcode.com/problems/binary-tree-preorder-traversal/description/) / [力扣](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/)

## 2. 非递归实现二叉树的后序遍历
145\. Binary Tree Postorder Traversal (Medium)
[Leetcode](https://leetcode.com/problems/binary-tree-postorder-traversal/description/) / [力扣](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/)
> 其实是跟前序有点关系, 需要left和right反过来, 
> 利用前序, 最后翻转


## 3. 非递归实现二叉树的中序遍历
94\. Binary Tree Inorder Traversal (Medium)
[Leetcode](https://leetcode.com/problems/binary-tree-inorder-traversal/description/) / [力扣](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/)

# BST
二叉查找树（BST）：根节点大于等于左子树所有节点，小于等于右子树所有节点。
二叉查找树中序遍历有序。
## 1. 修剪二叉查找树
669\. Trim a Binary Search Tree (Easy)
[Leetcode](https://leetcode.com/problems/trim-a-binary-search-tree/description/) / [力扣](https://leetcode-cn.com/problems/trim-a-binary-search-tree/description/)
> 用前序. 先考虑用什么递归.

