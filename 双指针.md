# 双指针
## 1. 有序数组的 Two Sum
167. Two Sum II - Input array is sorted (Easy)

[Leetcode / 力扣](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)

> Input: numbers={2, 7, 11, 15}, target=9
> Output: index1=1, index2=2
> 题目描述：在有序数组中找出两个数，使它们的和为 target。

使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。

* 如果两个指针指向元素的和 sum == target，那么得到要求的结果；
* 如果 sum > target，移动较大的元素，使 sum 变小一些；
* 如果 sum < target，移动较小的元素，使 sum 变大一些。

数组中的元素最多遍历一次，时间复杂度为 O(N)。只使用了两个额外变量，空间复杂度为 O(1)。

```py
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        b = len(numbers)-1
        a = 0
        for c in numbers*2:
            if (numbers[a]+numbers[b])==target:
                return [a+1, b+1]
                break
            elif (numbers[a]+numbers[b])<target:
                a+=1
            else:
                b-=1
```

## 2. 两数平方和
633. Sum of Square Numbers (Easy)

[Leetcode / 力扣](https://leetcode.com/problems/sum-of-square-numbers/description/)

> Input: 5
> Output: True
> Explanation: 1 * 1 + 2 * 2 = 5
> 题目描述：判断一个非负整数是否为两个整数的平方和。

可以看成是在元素为 0~target 的有序数组中查找两个数，使得这两个数的平方和为 target，如果能找到，则返回 true，表示 target 是两个整数的平方和。

本题和 167. Two Sum II - Input array is sorted 类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用双指针得到两个数，使其平方和为 target。

本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 02 + x2 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。

因为最多只需要遍历一次 0~sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。

## 4. 回文字符串 (*)
680. Valid Palindrome II (Easy)

Runtime: 240 ms, faster than 16.45% of Python3 online submissions for Valid Palindrome II.
Memory Usage: 14.2 MB, less than 6.25% of Python3 online submissions for Valid Palindrome II.

```py
class Solution:
    def validPalindrome(self, s: str) -> bool:
        a = 0
        b = len(s)-1
        ss = list(s)
        n = 1
        while a < b:
            if n == -1:
                print(1)
                return False
            elif ss[a] == ss[b]:
                a+=1
                b-=1
            elif ss[a] != ss[b]:
                n-=1
                if (ss[a+1:b] == ss[-len(s)+b:-len(s)+a+1:-1]):
                    a+=1
                elif (ss[a:b-1] == ss[-len(s)+b-1:-len(s)+a:-1]):
                    b-=1
                else:
                    return False
        return True
```

## 5. 归并两个有序数组 (***)
88. Merge Sorted Array (Easy)

> Runtime: 32 ms, faster than 84.19% of Python3 online submissions for Merge Sorted Array.
Memory Usage: 12.7 MB, less than 100.00% of Python3 online submissions for Merge Sorted Array.

```py
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        a = m-1
        b = n-1
        s = (m+n)-1
        while a>=0 or b>=0:
            if a<0:
                nums1[s]=nums2[b]
                b-=1
                s-=1
            elif b<0:
                nums1[s]=nums1[a]
                a-=1
                s-=1
            elif (nums1[a] < nums2[b]):
                nums1[s]=nums2[b]
                b-=1
                s-=1
            elif (nums1[a] > nums2[b]):
                nums1[s]=nums1[a]
                a-=1
                s-=1
            else:
                nums1[s],nums1[s-1]=nums1[a],nums2[b]
                a-=1
                b-=1
                s-=2
```

## 6. 判断链表是否存在环 (***)

so cool!
* 要学会判断是否为空的简单版语句
* 双指针一个在前一个在后可以判断是否为圈
141. Linked List Cycle (Easy)
```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if not head:
            return False
        l1, l2 = head, head.next
        while l1 and l2 and l2.next:
            if l1 == l2:
                return True
            else:
                l1 = l1.next
                l2 = l2.next.next
        return False
```

## 7. 最长子序列 (***)

524. Longest Word in Dictionary through Deleting (Medium)
* 判断一个字符是否是另一个通过删除任意字符后的字符, 可以直接用双指针一个一个按序对比
```py
class Solution:
    def findLongestWord(self, s: str, d: List[str]) -> str:
        longeststring = ''
        for traget in d:
            i = 0
            j = 0
            while i < len(s) and j <len(traget):
                if s[i] == traget[j]:
                    j+=1
                i+=1
            if j == len(traget) and len(traget) > len(longeststring):
                longeststring = traget
        return longeststring
#需要调整, 因为答案不唯一
```


